/*
 * ===========================================
 * CP1.4 - Reto 1 (CI) - Jenkinsfile (develop)
 * ===========================================
 *
 * Stages:
 * - Get Code (develop)
 * - Static Test (flake8 + bandit) -> sin quality gate, solo exige reportes
 * - Deploy (SAM) -> staging (no interactivo)
 * - Rest Test (pytest integration) -> si falla, aborta pipeline
 * - Promote -> commit forzado + merge develop -> master + push
 *
 * Visualización:
 * - Warnings Next Generation: recordIssues() con parser pyLint
 * - JUnit: junit() para tests de integración
 */

def shLogged(String label, String script) {
    sh(label: label, script: """#!/usr/bin/env bash
set -euo pipefail
${script}
""".stripIndent())
}

def ensureReportsDirs() {
    shLogged('Ensure reports dirs', """
        mkdir -p reports/static
        mkdir -p reports/deploy
        mkdir -p reports/rest
    """)
}

def logAgentInfo(String stageName) {
    shLogged("Agent info (${stageName})", """
        echo "=== Agent info: ${stageName} ==="
        whoami || true
        hostname || true
        echo "WORKSPACE=${env.WORKSPACE}"
    """)
}

def requireFile(String path) {
    shLogged("Require file: ${path}", """
        test -f "${path}"
        echo "OK: found ${path}"
    """)
}

pipeline {
    agent any

    options {
        timestamps()
        skipDefaultCheckout(true)
    }

    environment {
        PYTHON_BIN = '/opt/jenkins-tools/venv/bin/python'

        REPO_URL = 'https://github.com/alloci88/todo-list-aws.git'
        CI_BRANCH = 'develop'
        MASTER_BRANCH = 'master'

        REPORTS_DIR = 'reports'

        // Static reports (pylint-like para Warnings NG)
        FLAKE8_OUT = 'reports/static/flake8.out'
        BANDIT_OUT = 'reports/static/bandit.out'
        BANDIT_JSON = 'reports/static/bandit.json'

        // Deploy (según tu samconfig.toml)
        STACK_NAME_STAGING = 'staging-todo-list-aws'
        API_URL_FILE = 'reports/deploy/api_url.txt'

        // Rest tests
        REST_JUNIT = 'reports/rest/junit-integration.xml'

        // Git identity for CI commits
        GIT_USER_NAME = 'jenkins-ci'
        GIT_USER_EMAIL = 'jenkins-ci@example.local'
    }

    stages {

        stage('Get Code') {
            steps {
                logAgentInfo('Get Code')
                deleteDir()

                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${env.CI_BRANCH}"]],
                    userRemoteConfigs: [[url: "${env.REPO_URL}"]],
                    extensions: [[$class: 'CloneOption', shallow: false, depth: 0, noTags: false]]
                ])

                ensureReportsDirs()

                stash name: 'SRC',
                      includes: '**/*',
                      excludes: '.git/**,reports/**,**/__pycache__/**',
                      useDefaultExcludes: false
            }
        }

        stage('Static Test') {
            steps {
                logAgentInfo('Static Test')
                deleteDir()
                unstash 'SRC'
                ensureReportsDirs()

                // Flake8 SOLO src/ (requisito). --exit-zero => nunca falla por findings.
                shLogged('Run Flake8 (src only)', """
                    "${PYTHON_BIN}" -m flake8 src \\
                      --exit-zero \\
                      --format=pylint \\
                      > "${FLAKE8_OUT}"
                """)

                // Bandit SOLO src/
                // Generamos salida "pylint-like" para Warnings NG + JSON como evidencia.
                shLogged('Run Bandit (src only)', """
                    "${PYTHON_BIN}" -m bandit -r src \\
                      --exit-zero \\
                      -f custom -o "${BANDIT_OUT}" \\
                      --msg-template "{abspath}:{line}: [{test_id}] {msg}"
                    "${PYTHON_BIN}" -m bandit -r src \\
                      --exit-zero \\
                      -f json -o "${BANDIT_JSON}"
                """)

                // Requisito del enunciado: la etapa es OK si se publican informes
                requireFile(env.FLAKE8_OUT)
                requireFile(env.BANDIT_OUT)
                requireFile(env.BANDIT_JSON)
            }
            post {
                always {
                    // Warnings Next Generation (tendencias + UI)
                    // Parser pyLint: funciona con flake8 --format=pylint y con el bandit msg-template de arriba.
                    recordIssues(
                        enabledForFailure: true,
                        tools: [
                            pyLint(name: 'Flake8', pattern: "${FLAKE8_OUT}"),
                            pyLint(name: 'Bandit', pattern: "${BANDIT_OUT}")
                        ]
                    )

                    archiveArtifacts artifacts: 'reports/static/*', fingerprint: true, allowEmptyArchive: false
                }
            }
        }

        stage('Deploy') {
            steps {
                logAgentInfo('Deploy')
                deleteDir()
                unstash 'SRC'
                ensureReportsDirs()

                shLogged('SAM build', """
                    sam build
                """)

                shLogged('SAM validate', """
                    sam validate
                """)

                // Usa samconfig.toml (staging) y fuerza NO interactivo
                shLogged('SAM deploy (staging, non-interactive)', """
                    sam deploy \\
                      --config-env staging \\
                      --no-confirm-changeset \\
                      --no-fail-on-empty-changeset
                """)

                // Base URL por Outputs -> OutputKey = BaseUrlApi (según tu template)
                shLogged('Resolve API URL from CloudFormation outputs (BaseUrlApi)', """
                    API_URL=\\$(aws cloudformation describe-stacks \\
                        --stack-name "${STACK_NAME_STAGING}" \\
                        --query "Stacks[0].Outputs[?OutputKey=='BaseUrlApi'].OutputValue | [0]" \\
                        --output text)

                    if [[ -z "${API_URL}" || "${API_URL}" == "None" ]]; then
                        echo "ERROR: BaseUrlApi not found in stack outputs"
                        aws cloudformation describe-stacks --stack-name "${STACK_NAME_STAGING}" --query "Stacks[0].Outputs" --output table || true
                        exit 1
                    fi

                    echo "${API_URL}" | tee "${API_URL_FILE}"
                """)

                requireFile(env.API_URL_FILE)

                archiveArtifacts artifacts: 'reports/deploy/*', fingerprint: true, allowEmptyArchive: false

                stash name: 'DEPLOY_META',
                      includes: 'reports/deploy/*',
                      useDefaultExcludes: false
            }
        }

        stage('Rest Test') {
            steps {
                logAgentInfo('Rest Test')
                deleteDir()
                unstash 'SRC'
                unstash 'DEPLOY_META'
                ensureReportsDirs()

                shLogged('Run Pytest integration (abort on fail)', """
                    export BASE_URL="\\$(cat "${API_URL_FILE}")"
                    echo "BASE_URL=${BASE_URL}"

                    "${PYTHON_BIN}" -m pytest -q \\
                      --junitxml="${REST_JUNIT}" \\
                      test/integration
                """)
            }
            post {
                always {
                    junit testResults: 'reports/rest/*.xml', allowEmptyResults: false
                    archiveArtifacts artifacts: 'reports/rest/*,reports/deploy/*', fingerprint: true, allowEmptyArchive: true
                }
            }
        }

        stage('Promote') {
            steps {
                logAgentInfo('Promote')
                deleteDir()
                unstash 'SRC'

                withCredentials([string(credentialsId: 'GITHUB_TOKEN', variable: 'GH_TOKEN')]) {
                    shLogged('Git promote develop -> master (protect Jenkinsfiles on master)', """
                        git config user.name "${GIT_USER_NAME}"
                        git config user.email "${GIT_USER_EMAIL}"

                        git remote set-url origin "https://${GH_TOKEN}@github.com/alloci88/todo-list-aws.git"
                        git fetch origin

                        # Forzar cambio "elegante" para que haya algo que mergear
                        echo "Promoted by Jenkins build ${BUILD_NUMBER} at \\$(date -Iseconds)" >> CHANGELOG.md
                        git add CHANGELOG.md
                        git commit -m "chore(release): promote build ${BUILD_NUMBER}" || true
                        git push origin "${CI_BRANCH}"

                        # Merge develop -> master
                        git checkout "${MASTER_BRANCH}"
                        git pull origin "${MASTER_BRANCH}"
                        git merge --no-ff "origin/${CI_BRANCH}" -m "merge: ${CI_BRANCH} -> ${MASTER_BRANCH} (build ${BUILD_NUMBER})"

                        # PROTECCIÓN: mantener los Jenkinsfiles propios de master
                        # (Si no existen, no fallamos)
                        git checkout --ours Jenkinsfile 2>/dev/null || true
                        git checkout --ours Jenkinsfile_agentes 2>/dev/null || true
                        git add Jenkinsfile Jenkinsfile_agentes 2>/dev/null || true

                        # Si hemos tocado algo, lo metemos en el commit del merge
                        git commit --amend --no-edit || true

                        git push origin "${MASTER_BRANCH}"
                    """)
                }
            }
        }
    }
}

